## pre-scriptum: в Стилях Notepad++ настройте цвет STRINGEOL, чтобы отличать мои комментарии ##, в PyCharm для этого надо редактировать файл цветовой схемы

## ==========  1  ========== ##

class Tetr:
    def __init__(self, AB=1, BC=1, AC=1, AD=1, BD=1, CD=1):
        ## формулы, которые вы используете ниже, верны только для правильного тетраэдра,
        ##   а это означает, что достаточно задать длину только одного ребра
        self.AB = AB
        self.BC = BC
        self.AC = AC
        self.AD = AD
        self.BD = BD
        self.CD = CD

    ## в Titlecase и CamelCase пишут имена собственных классов, 
    ##   для имён методов используют lowercase или snake_case
    def Height(self):
        return ((2 * self.AD) / 3) ** 0.5

    def Square(self, a, b, c):
        p = (a + b + c) / 2
        return (p * (p-a) * (p-b) * (p-c)) ** 0.5

    def Tetr_S(self):
        S1 = self.Square(self.AB, self.BC, self.AC)
        S2 = self.Square(self.AB, self.AD, self.BC)
        S3 = self.Square(self.BC, self.BD, self.CD)
        S4 = self.Square(self.AC, self.AD, self.CD)
        print(f'Площадь тетраэдара: {S1 + S2 + S3 + S4}')

    def Volume(self):
        V = (self.Square(self.AB, self.BC, self.AC) * self.Height()) / 3
        print(f'Объём тетраэдара: {V}')


    ## в целом, построение класса верное
    ## на перспективу:
    ##   сейчас у вас есть возможность изменить длину рёбер после создания объекта, и методы
    ##   каждый раз вычисляют значения заново — это правильный подход для изменяемых объектов, 
    ##   но даже в этом случае стоит использовать кэширование для методов, с тем, чтобы они 
    ##   запоминали последнее вычисленное значение и пересчитывали значения только при 
    ##   изменении объекта
    ##   но если вы хотите неизменяемый объект, то стоит использовать конструктор для разовой 
    ##   инициализации полей и свойства для последующего разового вычисления необходимых значений — 
    ##   это позволит использовать такие объекты с заметно большей производительностью


t1 = Tetr()
t1.Tetr_S()
t1.Volume()



## ==========  2  ========== ## 

from datetime import datetime, timedelta, time

class Period_of_day:
    ## приватный атрибут класса — используем ниже
    ## periods = ('ночь', 'утро', 'день', 'вечер')
    
    def __init__(self, u=0):
        self.utc0 = datetime.utcnow()
        ## имена атрибутов должны быть значащими: utc_offset например
        self.u = u

    ## этот метод представляется лишним
    def Tzone(self):
        p = self.utc0 + timedelta(hours=self.u)
        ## у типа datetime есть атрибут hour — нет нужды получать новый объект методом time()
        return p.time().hour

    def Period(self):
        ## имя i — для индексов
        i = self.Tzone()
        ## вместо метода Tzone()
        ## h = (self.utc0 + timedelta(hours=self.u)).hour
        
        if 0 <= i < 6: 
            print('ночь')
        elif 6 <= i < 12: 
            print('утро')
        elif 12 <= i < 18: 
            print('день')
        elif 18 <= i < 24: 
            print('вечер')
        ## если решили использовать такие ровные промежутки времени, то оптимизируйте:
        ## print(self.__class__.periods[h//6])


    ## не считая одного лишнего метода, класс выстроен правильно для текущего уровня
    ## но в целом, едва ли эффективно для каждого подобного вычисления создавать 
    ##   и хранить отдельный экземпляр отдельного класса
    ## так что в перспективе данный класс явно стоит перепроектировать: 
    ##   подумайте, каким образом — есть ещё несколько способов


c = int(input('Введите часовой пояс (UTC): '))
t1 = Period_of_day(c)
t1.Period()
