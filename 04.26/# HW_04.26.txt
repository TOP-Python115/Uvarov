  ==========  1  ==========
  
Во вспомогательном файле с именем 1_2.py напишите функцию important_message(), которая принимает строку с текстом и печатает в терминале сообщение, обрамлённое рамкой в ширину консоли и такой высоты, чтобы между текстом и рамкой с каждой стороны оставалось по одной пустой строке

Для того, чтобы узнать ширину окна консоли, используйте функцию из модуля shutil:

    https://docs.python.org/3/library/shutil.html#shutil.get_terminal_size

В основном файле 1.py напишите условно-бесконечный цикл приёма команд от пользователя. 

По вводу команды msg с последующим аргументом в виде строки вызовите функцию important_message() из файла 1_2.py

По команде quit осуществите выход из цикла.

Пример ввода:
    msg Now you're looking at the very important message from the team of the developers of this miraculous script
    
Пример вывода:
    
    #==============================================================================#
    #                                                                              #
    #  Now you're looking at the very important message from the team of the deve  #
    #  lopers of this miraculous script                                            #
    #                                                                              #
    #==============================================================================#



  ==========  2  ==========
  
Иногда, приложение не может обнаружить свои файлы в каталогах по-умолчанию. В таких случаях приложение запрашивает у пользователя путь, по которому можно найти потерянный файл.
Нам необходимо написать код, который обеспечивает именно такую функциональность.

Для этого мы создадим три файла в двух разных каталогах: 
	\folder1\2.py, в нём находится точка входа в нашу программу (этот файл мы передаём интерпретатору)
	\folder1\2_1.py, здесь находится функция return_file()
	\folder2\2_2.py, этот файл находится в другой папке и содержит один вызов функции print(“2_2.py: Я нашёлся!”)

В файле с именем 2_1.py напишите функцию return_file(), которая в качестве аргумента принимает путь к искомому файлу 2_2.py и копирует этот файл в каталог с файлом 2.py

В основном файле сначала получаем путь, по которому размещён файл 2_2.py
Необходимо, чтобы пользователь вводил полный путь, включая имя файла. 
Затем, вызываем функцию return_file(), передавая ей в качестве аргумента полученный от пользователя ввод. 
После успешного копирования, выполняем инструкцию import для возвращённого файла 2_2.py.

Для работы с путями используйте функцию Path() из модуля pathlib. Передайте функции строку, содержащую путь, и сохраните объект, который функция возвращает – его можно использовать в качестве аргумента для большинства других функций, которые работают с путями.

    https://docs.python.org/3/library/pathlib.html#basic-use

При прописывании путей ОС Windows в коде в виде строк используйте двойной обратный слэш '\\'.

Для копирования файла, воспользуйтесь функцией copy() из модуля shutil. Функция принимает два аргумента: путь к файлу, который подлежит копированию, и путь к папке, в которую необходимо скопировать файл.

    https://docs.python.org/3/library/shutil.html#shutil.copy



  ==========  3  ==========

Необходимо перебрать файлы в каталоге по переданному пути и вывести список файлов, которые старше семи дней

Напишите функцию, которая первым позиционно-ключевым аргументом принимает путь к каталогу, вторым ключевым аргументом принимает количество дней со значением по-умолчанию 7

Функция должна возвращать список (list) путей (объектов Path) к файлам

Основная программа должна принимать от пользователя путь к нужному каталогу и вызывать вышеописанную функцию, передавая ей введённый путь

В качестве проверка работоспособности скрипта введите в программу путь к каталогу с сохранёнными нашими скриптами с примерами

Используйте модуль pathlib:

    # абсолютный или относительный путь к нужному каталогу
    path = ""
    # итерация по файлам и каталогам в текущем каталоге
    for file in Path(path).glob('*'):
        # возвращает дату и время последнего доступа к файлу в POSIX формате
        file.stat().st_atime
    
    https://docs.python.org/3/library/pathlib.html#pathlib.Path.glob
    https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file
    https://docs.python.org/3/library/pathlib.html#pathlib.Path.stat
    https://docs.python.org/3/library/os.html#os.stat_result.st_mtime

Используйте тип datetime из модуля datetime:

    Для работы с POSIX форматом даты/времени в типе datetime используются методы timestamp
    
    https://docs.python.org/3/library/datetime.html#datetime.datetime.fromtimestamp
    
    Тип datetime поддерживает арифметические операции с датами и временем – в результате таких операций получается тип timedelta
    
    https://docs.python.org/3/library/datetime.html#datetime.timedelta



  ==========  4  ==========

Напишите скрипт, генерирующий вашу собственную таблицу символов, и сохраняющий её в JSON строку

Символы должны быть объединены по группам. У каждого символа должен быть свой уникальный код

https://docs.python.org/3/library/itertools.html#itertools.chain
https://docs.python.org/3/library/json.html#json.dumps

Программа должна напечатать получившуюся строку в консоли

Пример структуры:
    {
        "whitespace": {
            "0": " ",
            "1": "\t",
            ...
        },
        "digits": {
            "5": "0",
            "6": "1",
            ...
        },
        "punctuation": {
            "20": ".",
            "21": ",",
            ...
        },
        "latin": {
            "lowercase": {
                "43": "a",
                "44": "b",
                ...
            },
            "uppercase": {
                "70": "A",
                "71": "B",
                ...
            },
        },
        "cyrrilic": {
            "lowercase": {
                "97": "а",
                "98": "б",
                ...
            },
            "uppercase": {
                "131": "А",
                "132": "Б",
                ...
            },
        },
        "japaneese": {
            "hiragana": {
                "165": "あ",
                "166": "い",
                ...
            },
            "katakana": {
                "212": "チ",
                "213": "ニ",
                ...
            },
            ...
        },
        ...
    }



  =========================

Код каждой решённой задачи помещается в текущий каталог репозитория в виде отдельного файла с именем, соответствующем номеру задачи.

Все файлы выполняются с помощью интерпретатора.
Текстовый вывод в стандартный поток stdout копируется.
Копия вывода в виде комментария помещается в конец файла с кодом задачи.

В сервис Журнал отправляется сообщение о выполнении задания со ссылкой на репозиторий.

Преподаватель пишет комментарии и правки в коде задач и обновляет файлы в удалённом репозитории.
Проверяйте обновления в своём репозитории каждый день.